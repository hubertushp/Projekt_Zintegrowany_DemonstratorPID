/* PID balance code with ping pong ball and distance sensor sharp 2y0a21
 *  by ELECTRONOOBS: https://www.youtube.com/channel/UCjiVhIvGmRZixSzupD0sS9Q
 *  Tutorial: http://electronoobs.com/eng_arduino_tut100.php
 *  Code: http://electronoobs.com/eng_arduino_tut100_code1.php
 *  Scheamtic: http://electronoobs.com/eng_arduino_tut100_sch1.php
 *  3D parts: http://electronoobs.com/eng_arduino_tut100_stl1.php
 */
#include <Arduino.h>
#include <ESP32Servo.h>
#include <Wire.h>

///////////////////////Inputs/outputs///////////////////////
// int Analog_in = A0;
const int TRIG_PIN = 25;
const int ECHO_PIN = 26;
const int servo_pin = 12;

Servo myservo; // create servo object to control a servo, later attatched to D9
///////////////////////////////////////////////////////

////////////////////////Variables///////////////////////
int Read = 0;
float distance = 0.0;
float elapsedTime, t, timePrev; // Variables for time control
float distance_previous_error, distance_error;
int period = 50; // Refresh rate period of the loop is 50ms
///////////////////////////////////////////////////////

///////////////////PID constants///////////////////////
float kp = 1; // Mine was 8
float ki = 0; // Mine was 0.2
float kd = 0; // Mine was 3100
float distance_setpoint =
    25; // Should be the distance from sensor to the middle of the bar in mm
float PID_p, PID_i, PID_d, PID_total;
///////////////////////////////////////////////////////
float get_dist(int n) { // Zwraca odległość w mm

  // --- Nowa definicja funkcji get_dist dla HC-SR04 ---
  long totalDuration = 0;
  int validReadings = 0;
  float distance_mm_average = 0;

  // Zrób 'n' pomiarów i uśrednij
  for (int i = 0; i < n; i++) {
    // 1. Wyślij impuls wyzwalający (TRIG)
    digitalWrite(TRIG_PIN, LOW);
    delayMicroseconds(2); // Krótka pauza dla pewności
    digitalWrite(TRIG_PIN, HIGH);
    delayMicroseconds(10); // Impuls wyzwalający 10µs
    digitalWrite(TRIG_PIN, LOW);

    // 2. Zmierz czas trwania impulsu ECHO (w mikrosekundach)
    // pulseIn zwraca 0 jeśli czas oczekiwania (timeout) zostanie przekroczony
    // Timeout jest ważny, aby program się nie zawiesił, jeśli echo nie wróci
    // Domyślny timeout pulseIn to 1 sekunda, można ustawić krótszy
    // np. 30000µs to ok. 5 metrów - dostosuj w razie potrzeby
    float duration_us = pulseIn(ECHO_PIN, HIGH, 30000); // Timeout 30ms

    // 3. Przelicz czas na odległość (jeśli pomiar był udany)
    if (duration_us > 0) {
      // Prędkość dźwięku to ok. 343 m/s = 0.343 mm/µs
      // Odległość = (czas * prędkość) / 2  (dzielimy przez 2, bo echo leci tam
      // i z powrotem)
      float distance_mm = (duration_us * .0343) / 2;

      // Prosty filtr - odrzuć skrajne wartości (opcjonalnie, dostosuj zakres)
      if (distance_mm > 1 &&
          distance_mm < 2000) { // Przykładowy zakres dla HC-SR04 (5mm do 400mm)
        totalDuration +=
            duration_us; // Sumuj tylko poprawne czasy dla uśrednienia
        validReadings++;
      }
      // Serial.print("Distance: ");
      // Serial.println(distance_mm);
    }
    delay(50); // Mała przerwa między pomiarami, aby uniknąć interferencji ech
               // poprzednich pomiarów
  }

  // 4. Oblicz średnią odległość z poprawnych pomiarów
  if (validReadings > 0) {
    long averageDuration = totalDuration / validReadings;
    distance_mm_average = (averageDuration * .343) / 2;
  } else {
    // Co zrobić, jeśli nie było żadnych poprawnych odczytów?
    // Można zwrócić poprzednią wartość, maksymalny zasięg, albo jakąś stałą.
    // Zwrócenie dużej wartości może być bezpieczniejsze niż 0.
    Serial.println("Warning: No valid HC-SR04 readings!");
    // return 2000.0; // Zwróć maksymalną sensowną wartość (np. 400mm)
  }

  // Zwróć średnią odległość w milimetrach
  return distance_mm_average;
}

void setup() {
  Serial.begin(9600);
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  digitalWrite(TRIG_PIN, LOW);

  myservo.attach(servo_pin);
  myservo.write(125);
  t = millis();
}

void loop() {
  if (millis() > t + period) {
    t = millis();
    distance = get_dist(100);
    Serial.print("Distance ");
    Serial.println(distance);
    distance_error = distance_setpoint - distance;
    PID_p = kp * distance_error;
    float dist_diference = distance_error - distance_previous_error;
    PID_d = kd * ((distance_error - distance_previous_error) / period);

    if (-3 < distance_error && distance_error < 3) {
      PID_i = PID_i + (ki * distance_error);
    } else {
      PID_i = 0;
    }

    PID_total = PID_p + PID_i + PID_d;
    // PID_total = map(PID_total, -150, 150, 0, 150);

    // if (PID_total < 20) {
    //   PID_total = 20;
    // }
    // if (PID_total > 160) {
    //   PID_total = 160;
    // }
    float servoAngle = map(PID_total, -150, 150, 10, 170);

    servoAngle = constrain(servoAngle, 10, 170);
    myservo.write(servoAngle);
    distance_previous_error = distance_error;
  }
}
